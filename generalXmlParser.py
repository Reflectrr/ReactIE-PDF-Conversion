import xml.etree.ElementTree as ET
import collections
import json
import os
import sys, getopt
import re
import shutil

defaultDir = "bio_paper" # default directory to store the PDF to be parsed
tabWidth = 10
lineHeight = 12

weirdChar = { # weird characters generated by Symbol Scraper that need to be replaced
    "\u2212": "-",  # long dash
    "\ufb00": "ff",
    "\ufb01": "fi",
    "\ufb02": "fl",
    "\ufb03": "ffi",
    "fraction(-)": "",  # weird output of SymbolScraper
    "\u25a0": "",
}

# given a path to an xml file, modify the file to make it a valid xml file
def preParseXML(path):
    with open(path, "r") as file:
        filedata = file.read()
    # replace all invalid xml characters with valid ones
    filedata = filedata.replace(">&<", ">&amp;<")
    filedata = filedata.replace("><<", ">&lt;<")
    filedata = filedata.replace(">><", ">&gt;<")
    filedata = filedata.replace("", "")
    filedata = filedata.replace(chr(0), "")
    # remove all ascii characters that are not tab, newline, or carriage return
    for invalidAscii in range(1, 31):
        if invalidAscii == 9 or invalidAscii == 10 or invalidAscii == 13:
            continue   # tab, newline, carriage return 
        char = chr(invalidAscii)
        filedata = filedata.replace(char, "")
    # write the modified xml file back to the original path
    with open(path, "w") as file:
        file.write(filedata)

# given a string or an array of strings, add the word to the end of the string
def updateText(inputObject, word):
    if not inputObject:
        return word
    elif isinstance(inputObject, str):
        # don't join with space if inputObject ends with a hyphen
        if inputObject and inputObject[-1] == "-":
            inputObject += word
        else:
            inputObject += " " + word
    else:
        # don't join with space if the last inputObject ends with a hyphen
        if inputObject and inputObject[-1] and inputObject[-1][-1] == "-":
            inputObject[-1] += word
        else:
            inputObject[-1] += " " + word
    return inputObject

# given an word xml element, return the word as a string
def buildWord(wordXml):
    wordBuf = ""
    for char in wordXml.iter("Char"):
        wordBuf += (
            weirdChar[str(char.text)] if char.text in weirdChar else str(char.text)
        )
    return wordBuf


# def checkSideLine(lineXml):
#     location = lineXml.attrib["BBOX"].split(" ")[0]
#     return location in ["9.0", "18.0"]


# def checkIgnoredPrefix(line):
#     for prefix in ignoredSuffix:
#         if line.startswith(prefix):
#             return True
#     return False


def outputJsonFile(xmlPath, output):
    outputFileName = xmlPath.split("/")[-1][:-4] + ".json"
    path = os.getcwd()
    result_directory = path + "/result/"
    if not os.path.exists(result_directory):
        os.mkdir(result_directory)
    outputFileName = result_directory + outputFileName
    with open(outputFileName, "w") as outfile:
        json.dump(output, outfile, indent=4)
    print("Parsed pdf successfully written to", outputFileName)


# find the two most common line start positions
def findOffset(root):
    lineStartPos = collections.defaultdict(int)
    for lineXml in root.iter("Line"):
        location = round(float(lineXml.attrib["BBOX"].split(" ")[0]))
        lineStartPos[location] += 1
    twoMean = sorted(lineStartPos.items(), key=lambda x: x[1], reverse=True)[:2]
    res = [twoMean[0][0], twoMean[1][0]]
    return res

# given a line xml element, check if it is the start of a paragraph
def checkStartParagrph(lineXmlBBOX, paragraphStart):
    startX = float(lineXmlBBOX.split(" ")[0])
    return roughEqual(startX-tabWidth, paragraphStart[0], 5) or roughEqual(startX-tabWidth, paragraphStart[1], 5)

# given a line of text, check if it is the end of a paragraph
# logic is done by checking if the page starts rendering graphs
def checkEndOfPage(text):
    text = text.lower()
    if re.match("^(scheme|table|figure) [1-9]. ", text):
        print('here')
        return True
    else:
        return False

# given a path, make sure the path is valid (rename if needed)
# valid path is returned
def validateFilename(inputfile: str):
    newFilename = inputfile.replace(" ", "_").replace("(", "_").replace(")", "_")
    os.rename(inputfile, newFilename)
    return newFilename

# check if the start of two lines are very far from each other
def checkLinesFar(line1BBOX, line2BBOX):
    threshold = 20
    xMin1, yMin1 = line1BBOX.split(" ")[0], line1BBOX.split(" ")[1]
    xMin2, yMin2 = line2BBOX.split(" ")[0], line2BBOX.split(" ")[1]
    return abs(float(xMin1) - float(xMin2)) > threshold or abs(float(yMin1) - float(yMin2)) > threshold

# check if two lines start at the same x position
def checkSameStartX(line1BBOX, line2BBOX):
    xMin1, yMin1 = line1BBOX.split(" ")[0], line1BBOX.split(" ")[1]
    xMin2, yMin2 = line2BBOX.split(" ")[0], line2BBOX.split(" ")[1]
    return roughEqual(float(xMin1), float(xMin2), 5)

# check if new paragraph based on current line and previous line
def checkNewParagraph(currLineBBOX, prevLineBBOX, offsets):
    if not prevLineBBOX:
        return True
    xMinCurr, yMinCurr, xMaxCurr, yMaxCurr = currLineBBOX.split(" ")
    xMinPrev, yMinPrev, xMaxPrev, yMaxPrev = prevLineBBOX.split(" ")
    # convert to float
    xMinCurr, yMinCurr, xMaxCurr, yMaxCurr = float(xMinCurr), float(yMinCurr), float(xMaxCurr), float(yMaxCurr)
    xMinPrev, yMinPrev, xMaxPrev, yMaxPrev = float(xMinPrev), float(yMinPrev), float(xMaxPrev), float(yMaxPrev)
    # not a new paragraph if the current line is the same as the previous line
    if checkSameLine(currLineBBOX, prevLineBBOX):
        return False
    elif checkSameStartX(currLineBBOX, prevLineBBOX) and not checkLinesFar(currLineBBOX, prevLineBBOX):
        return False
    # if the current line is indented and the previous line is not
    if xMinCurr > xMinPrev and roughEqual(xMinCurr-xMinPrev, tabWidth, 5) and roughEqual(yMinCurr - yMinPrev, lineHeight, 5):
        return True
    # if the current line far from the previous line, and the two lines are not in two columns
    elif checkLinesFar(currLineBBOX, prevLineBBOX) and not (roughEqual(xMinCurr, max(offsets), 10) and roughEqual(xMinPrev, min(offsets), 10)):
        return True
    elif checkStartParagrph(currLineBBOX, offsets):
        return True
    else:
        return False

# check if two line xml elements are on the same line
def checkSameLine(line1BBOX, line2BBOX):
    if not line1BBOX or not line2BBOX:
        return False
    y1 = float(line1BBOX.split(" ")[1])
    y2 = float(line2BBOX.split(" ")[1])
    return roughEqual(y1, y2, 5) # line spacing is around 10, so using a threshold of something less than 10

# combine two lines of text with the same y coordinate
def combineLines(line1BBOX, line2BBOX):
    xMin1, yMin1, xMax1, yMax1 = line1BBOX.split(" ")
    xMin2, yMin2, xMax2, yMax2 = line2BBOX.split(" ")
    xMin = min(float(xMin1), float(xMin2))
    xMax = max(float(xMax1), float(xMax2))
    # recreate the bbox string
    bbox = str(xMin) + " " + str(yMin1) + " " + str(xMax) + " " + str(yMax1)
    return bbox

# check if two numbers are roughly equal
def roughEqual(a, b, threshold):
    return abs(a - b) < threshold

# given a path to a pdf file, parse the pdf file and output a json file
# both symbol scraper and xml parser are run
def parseFile(pdfPath: str):
    # create temp dir if not exist
    tempDirPath = "./xmlFiles/"
    if not os.path.exists(tempDirPath):
        os.mkdir(tempDirPath)
    # don't run SymbolScraper if xml already parsed
    xmlPath = tempDirPath + pdfPath.split("/")[-1][:-4] + ".xml"
    if os.path.exists(xmlPath):
        # print("XML file already exists")
        # print("xmlpath", xmlPath)
        ...
    else:
        print("Parsing", pdfPath)
        os.system(
            "SymbolScraper/bin/sscraper " + pdfPath + " " + tempDirPath + " > /dev/null"
        )
    # don't parse xml if json already exists
    targetJsonPath = os.getcwd() + "/result/" + pdfPath.split("/")[-1][:-4] + ".json"
    if os.path.exists(targetJsonPath):
        print("JSON file already exists")
        parse(xmlPath)
        return
    else:    
        parse(xmlPath)
    # clean up useless .md files created by SymbolScraper
    pdfDirPath = os.path.dirname(pdfPath)
    for mdFile in os.listdir(pdfDirPath):
        if mdFile.endswith(".md") and mdFile != "README.md":
            os.remove(pdfDirPath + "/" + mdFile)

# given a path to a folder, recursively parse all pdf files in it
def parseFolder(folderPath: str):
    for item in sorted(os.listdir(folderPath)):
        itemPath = os.path.join(folderPath, item)
        if itemPath.endswith(".pdf"):
            validPath = validateFilename(itemPath)
            parseFile(validPath)
        elif os.path.isdir(itemPath):
            validPath = validateFilename(itemPath)
            parseFolder(validPath)
        # print()

# given a path to a xml file, parse the xml file and output a json file
def parse(inputXml: str):
    preParseXML(inputXml)
    tree = ET.parse(inputXml)  # improvement: change to argument based input
    root = tree.getroot()

    output = {}
    output["fullText"] = ""
    output["content"] = []

    paragraphStart = findOffset(root)

    for pageXml in root.iter("Page"):
        prevLineBBOX = None
        for lineXml in pageXml.iter("Line"):
            # building line content
            lineContent = ""
            lineXMLBBOX = lineXml.attrib["BBOX"]
            for wordXml in lineXml.iter("Word"):
                word = buildWord(wordXml)
                lineContent = updateText(lineContent, word)
            lineContent = lineContent.strip()

            # update outputs
            output["fullText"] = updateText(output["fullText"], lineContent)
            if checkNewParagraph(lineXMLBBOX, prevLineBBOX, paragraphStart):
                output["content"].append(lineContent)
            else:
                output["content"][-1] = updateText(output["content"][-1], lineContent)
            # update prevLineBBOX
            if checkSameLine(lineXMLBBOX, prevLineBBOX):
                prevLineBBOX = combineLines(lineXMLBBOX, prevLineBBOX)
            else:
                prevLineBBOX = lineXMLBBOX
            # if the line is a graph, skip the rest of the page
            if checkEndOfPage(lineContent):
                break
    outputJsonFile(inputXml, output)

# clear everything in the xml and result folder
def cleanFolders():
    path = os.getcwd()
    xml_directory = path + "/xmlFiles/"
    result_directory = path + "/result/"
    # if os.path.exists(xml_directory):
    #     shutil.rmtree(xml_directory)
    if os.path.exists(result_directory):
        shutil.rmtree(result_directory)

# main function
if __name__ == "__main__":
    argv = sys.argv[1:]
    inputfile = ""
    opts, args = getopt.getopt(argv, "hi:")
    for opt, arg in opts:
        if opt == "-h":
            print("[Usage]: python3 xmlParser.py -i <inputPDF>")
            print("Result will be saved as a .json in ./result/")
            sys.exit()
        elif opt == "-i":
            inputfile = arg
            parseFile(inputfile)
    if not opts:
        cleanFolders()
        cwd = os.getcwd()
        target_dir = os.path.join(cwd, defaultDir)
        parseFolder(target_dir)
